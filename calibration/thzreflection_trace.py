"""
script: thzreflection_trace.py
author:  Chun Tung, Cheung (ctcheung1123@gmail.com)
date created: 2024/10/03
last update: 2024/10/03

(doc string generated by codeium)
This script is used to measure the THz reflection.
The THz pulse is triggered by a digital pulse from the pulser, and the
reflection is measured with a zero-biased diode connected to the NIDAQmx. The
laser and apd are not used in this measurement.

The script uses the Measurement class as a base class, which is defined in
the task_base.py module. This class provides the necessary methods to
perform a measurement, including the setup of the instruments and the
acquisition of the data.
"""

from math import lcm

import nidaqmx
import numpy as np
from nidaqmx.constants import AcquisitionType, Coupling, Edge
from nidaqmx.stream_readers import AnalogSingleChannelReader
from scipy.optimize import curve_fit

from hardware import config as hcf
from hardware.hardwaremanager import HardwareManager
from hardware.pulser.pulser import (
    HIGH,
    LOW,
    REPEAT_INFINITELY,
    OutputState,
    TriggerRearm,
    TriggerStart,
)
from measurement.task_base import Measurement

hw = HardwareManager()


def rc_square_wave_with_offset(
    t, frequency, amplitude, phase, amp_discharge, rc, offset
):
    """
    A model of a square wave with an RC low-pass filter and an offset

    Parameters
    ----------
    t : array_like
        Time array
    frequency : float
        Frequency of the square wave
    amplitude : float
        Amplitude of the square wave
    phase : float
        Phase of the square wave
    amp_discharge : float
        Amplitude of the discharge
    rc : float
        Time constant of the RC low-pass filter
    offset : float
        Offset of the signal

    Returns
    -------
    array_like
        The model signal
    """
    period = 1 / frequency
    half_period = period / 2
    dt = (t[-1] - t[0]) / len(t)
    t_shifted = (t + phase / (2 * np.pi * frequency)) % period  # Shift by phase

    # smoothness = 0.2*(t[1]-t[0])
    smoothness = period / 1000.0
    smoothedge1 = (
        1
        - np.exp(-t_shifted / smoothness)
        - np.exp(-(half_period - t_shifted) / smoothness)
    )
    smoothedge2 = (
        1
        - np.exp(-(t_shifted - half_period) / smoothness)
        - np.exp(-(period - t_shifted) / smoothness)
    )

    rc_wave = np.zeros_like(t)
    flipflop = t_shifted < half_period
    rcwave_fronthalf = amplitude * smoothedge1 - amp_discharge * (
        1 - np.exp(-t_shifted / rc)
    )
    rcwave_endhalf = -amplitude * smoothedge2 + amp_discharge * (
        1 - np.exp(-(t_shifted - half_period) / rc)
    )
    rc_wave = flipflop * rcwave_fronthalf + (~flipflop) * rcwave_endhalf
    # Add the offset to the square wave and the RC modification
    return rc_wave + offset


def square_wave_with_offset(t, frequency, amplitude, phase, offset):
    """
    A model of a square wave with an offset

    Parameters
    ----------
    t : array_like
        Time array
    frequency : float
        Frequency of the square wave
    amplitude : float
        Amplitude of the square wave
    phase : float
        Phase of the square wave
    offset : float
        Offset of the signal

    Returns
    -------
    array_like
        The model signal
    """
    period = 1 / frequency
    half_period = period / 2
    dt = (t[-1] - t[0]) / len(t)
    t_shifted = (t + phase / (2 * np.pi * frequency)) % period  # Shift by phase
    rc_wave = np.zeros_like(t)
    # smoothness = 0.2*(t[1]-t[0])
    smoothness = period / 1000.0
    smoothedge1 = (
        1
        - np.exp(-t_shifted / smoothness)
        - np.exp(-(half_period - t_shifted) / smoothness)
    )
    smoothedge2 = (
        1
        - np.exp(-(t_shifted - half_period) / smoothness)
        - np.exp(-(period - t_shifted) / smoothness)
    )
    flipflop = t_shifted < half_period
    rcwave_fronthalf = amplitude * smoothedge1
    rcwave_endhalf = -amplitude * smoothedge2
    rc_wave = flipflop * rcwave_fronthalf + (~flipflop) * rcwave_endhalf
    # Add the offset to the square wave and the RC modification
    return rc_wave + offset


def estimate_rcsquare(xx, yy):
    """
    Estimate the parameters of the rc_square_wave_with_offset model

    Parameters
    ----------
    xx : array_like
        Time array
    yy : array_like
        Signal array

    Returns
    -------
    initial_guess : list
        The estimated parameters
    """
    amp_guess = (np.max(yy) - np.min(yy)) / 2.0
    yybase = np.mean(yy)
    yy_shifted = yy - yybase
    idx_neg = np.where(yy_shifted < 0)[0][0]
    idx_pos = np.where(yy_shifted > 0)[0][0]
    initial_guess = [
        0.5 / abs(xx[idx_neg] - xx[idx_pos]),
        amp_guess,
        0.1,
        amp_guess,
        25e3,
        yybase,
    ]
    return initial_guess


def fit_rcsquare(xx, yy, initial_guess, bounds):
    """
    Fit the rc_square_wave_with_offset model to the data

    Parameters
    ----------
    xx : array_like
        Time array
    yy : array_like
        Signal array
    initial_guess : list
        The initial guess of the parameters
    bounds : list
        The bounds for the parameters

    Returns
    -------
    params_opt : list
        The optimized parameters
    params_cov : array_like
        The covariance matrix of the parameters
    """
    # do a fit------------------------------
    params_opt, params_cov = curve_fit(
        rc_square_wave_with_offset, xx, yy, p0=initial_guess, bounds=bounds
    )
    # params_opt, params_cov = curve_fit(rc_square_wave_with_offset, xx, yy, p0=initial_guess)

    return params_opt, params_cov


class THzReflectionTrace(Measurement):
    """
    Measurement class for THz reflection trace measurement
    """

    def __init__(self, name="default"):
        # !!< has to be specific by users>
        __paraset = dict(
            mwfreq=398.556,  # [GHz] # MW frequency after AMC
            mwpower=5.0,  # [V] # MW power
            pulse_rate=5e3,  # [Hz] # better to be multiple of the daq sampling rate
            daq_max=1.0,  # [V] # maximum voltage of the DAQ card
            daq_min=-1.0,  # [V] # minimum voltage of the DAQ card
            daq_srate=hcf.NI_sampling_max,  # [Hz] # daq sampling rate
            refresh=25,  # [Hz] # refresh rate of the plot
            window=2.0,  # [s] # time window of the measurement
        )
        # !!< has to be specific by users>
        __dataset = dict(mwfreq=0, zbd_time=np.array([10]), zbd_amp=np.array([10]))
        # ==--------------------------------------------------------------------------
        super().__init__(name, __paraset, __dataset)

    def _setup_exp(self):
        super()._setup_exp()

        # set MW frequency and power -------------------------------------------------------
        mwfreq = self.paraset["mwfreq"]  # [GHz] MW frequency after AMC
        mwpower = self.paraset["mwpower"]  # [V]

        hw.mwsyn.open()
        freq_actual = hw.mwsyn.cw_frequency(mwfreq / hcf.VDISYN_multiplier)
        self.dataset["mwfreq"] = freq_actual * hcf.VDISYN_multiplier
        print(f"CW Freqeuncy Setting Sent:{mwfreq} GHz")
        print(f"Actual Output CW Freqeuncy :{self.paraset['mwfreq']} GHz")

        mwpower_vlevel = mwpower  # 5V equals to max power
        task_uca = nidaqmx.Task("UCA")  # user controlled attenuation
        task_uca.ao_channels.add_ao_voltage_chan(
            hcf.NI_ch_UCA, min_val=0, max_val=mwpower_vlevel * 1.2
        )
        task_uca.start()
        task_uca.write([mwpower_vlevel], auto_start=False)
        self.task_uca = task_uca
        # -----------------------------------------------------------------------
        # set up the NI DAQ board-----------------------------------------------
        daq_max = self.paraset["daq_max"]
        daq_min = self.paraset["daq_min"]
        daq_srate = self.paraset["daq_srate"]
        task_zbd = nidaqmx.Task("ZBD")  # user controlled attenuation
        task_zbd.ai_channels.add_ai_voltage_chan(
            hcf.NI_ch_ZBD, min_val=daq_min, max_val=daq_max
        )
        task_zbd.ai_coupling = Coupling.AC
        task_zbd.timing.cfg_samp_clk_timing(
            daq_srate,
            source=hcf.NI_ch_Clock,
            active_edge=Edge.RISING,
            sample_mode=AcquisitionType.CONTINUOUS,
        )
        task_zbd_readtrig = task_zbd.triggers.start_trigger
        task_zbd_readtrig.cfg_dig_edge_start_trig(hcf.NI_ch_Trig, Edge.RISING)
        task_zbd_readtrig.cfg_dig_edge_start_trig(hcf.NI_ch_Trig, Edge.RISING)
        task_zbd_reader = AnalogSingleChannelReader(task_zbd.in_stream)
        task_zbd_reader.read_all_avail_samp = True

        self.task_zbd = task_zbd
        self.task_zbd_readtrig = task_zbd_readtrig
        self.task_zbd_reader = task_zbd_reader
        # -------------------------------------------------------------------------
        # set the pulse sequence --------------------------------------------
        dt_daq = int(1.0 / self.paraset["daq_srate"] * 1e9)
        dt_pulse = int(1.0 / self.paraset["pulse_rate"] * 1e9)
        leastrepeat = lcm(dt_daq, dt_pulse)
        hw.pg.resetSeq()
        hw.pg.setDigital(
            "dtrig", [(dt_daq / 2.0, HIGH), (dt_daq / 2.0, LOW)], offset=True
        )
        hw.pg.setDigital(
            "mwA",
            [(dt_pulse / 2.0, LOW), (dt_pulse / 2.0, LOW)]
            * int(leastrepeat / dt_pulse),
            offset=True,
        )
        hw.pg.setDigital(
            "mwB",
            [(dt_pulse / 2.0, LOW), (dt_pulse / 2.0, HIGH)]
            * int(leastrepeat / dt_pulse),
            offset=True,
        )
        hw.pg.setDigital(
            "dclk",
            [(dt_daq / 2.0, LOW), (dt_daq / 2.0, HIGH)] * int(leastrepeat / dt_daq),
            offset=True,
        )
        hw.pg.setTrigger(start=TriggerStart.SOFTWARE, rearm=TriggerRearm.AUTO)
        hw.pg.stream(n_runs=REPEAT_INFINITELY)
        # -----------------------------------------------------------------------
        # some data structures -------------------------------------------------

        refresh = self.paraset["refresh"]
        window = self.paraset["window"]
        num_window = int(refresh * window)
        num_read = int(-(((1e9 / refresh) / leastrepeat) // -1) * leastrepeat / dt_daq)
        # print(f"num_read:{num_read}, num_window:{num_window}")
        self.daq_buffer = np.zeros(num_read, dtype=np.float64, order="C")
        if self.tokeep == False:
            self.zbd_amp = np.zeros(num_window, dtype=np.float64, order="C")
            self.zbd_time = np.arange(0, window, 1.0 / refresh)
        self.num_read = num_read

        # # for fitting rc square wave only
        # self.num_div = int(daq_srate*dt_pulse)
        # self.num_ptrepeat = int(num_read/self.num_div)
        # self.zbd_time = np.arange(0, self.num_div*dt_daq, dt_daq)
        # self.zbd_samples = np.zeros(num_read, dtype=np.float64, order='C')
        # self.zbd_aetrace = np.zeros(num_window, dtype=np.float64, order='C')
        # self.fit_bounds = ([0.0, 0.0, 0.0, 0.0, 0.0, -np.inf], [np.inf, np.inf, np.pi*2.0, np.inf, np.inf, np.inf])
        # -----------------------------------------------------------------------

        # start outputing seq and trigger the DAQ
        self.task_zbd.start()
        hw.pg.startNow()

    def _run_exp(self):
        # run the experiment
        # self.dataset = self.nidaq.read_data()
        # print(f"Run index is {self.idx_run}")
        numhaveread = self.task_zbd_reader.read_many_sample(
            self.daq_buffer, number_of_samples_per_channel=self.num_read, timeout=5.0
        )
        return numhaveread

    def _organize_data(self):
        # some basic data analysis ===========================================
        # Perform average on the signal absolute----------------------------------
        signal_nofloor = np.copy(self.daq_buffer)
        signal_nofloor = signal_nofloor - np.mean(signal_nofloor)
        peak_amplitude = np.mean(np.abs(signal_nofloor))
        # peak_amplitude = np.max(self.daq_buffer)
        self.zbd_amp[:-1] = self.zbd_amp[1:]
        self.zbd_amp[-1] = peak_amplitude

        # ------------------------------------------------------------

        # # perform numerical fit-----------------------
        # zbd_samples_reshape = np.reshape(np.copy(self.dqq_buffer), (self.num_ptrepeat, self.num_div))
        # self.zbd_samples = np.average(zbd_samples_reshape, axis=0)
        # para_guess = estimate_rcsquare(self.zbd_time, self.zbd_samples)
        # para_fit, params_cov = fit_rcsquare(self.zbd_time, self.zbd_samples, initial_guess=para_guess, bounds=self.fit_bounds)
        # amp = para_fit[1]
        # self.zbd_amp[:-1] = self.zbd_amp[1:]
        # self.zbd_amp[-1] = amp
        # amp_error = np.sqrt(np.diag(params_cov))[1]
        # self.zbd_aetrace[:-1] = self.zbd_aetrace[1:]
        # self.zbd_aetrace[-1] = amp_error
        # # ---------------------------------------------

        # # Perform FFT on the signal----------------------------------
        # daq_srate = self.paraset['daq_srate']
        # pulse_rate = self.paraset['pulse_rate']
        # fft_result = np.fft.fft(np.copy(self.dqq_buffer))
        # fft_freqs = np.fft.fftfreq(self.num_read, daq_srate/1E9)
        # # Get the positive frequencies and corresponding FFT values
        # positive_freqs = fft_freqs[fft_freqs >= 0]
        # positive_fft = np.abs(fft_result[fft_freqs >= 0])
        # # Find the peak amplitude at a specific frequency (e.g., 50 Hz)
        # target_frequency = pulse_rate/1E9
        # idx = (np.abs(positive_freqs - target_frequency)).argmin()  # Find the closest frequency bin
        # peak_amplitude = positive_fft[idx]
        # self.zbd_amp[:-1] = self.zbd_amp[1:]
        # self.zbd_amp[-1] = peak_amplitude/self.num_read*2
        # #------------------------------------------------------------

        # ===========================================================

        self.dataset = dict(
            zbd_time=self.zbd_time,
            zbd_amp=self.zbd_amp,
            # zbd_aetrace = self.zbd_aetrace,
        )
        super()._organize_data()

    def _handle_exp_error(self):
        try:
            hw.mwsyn.reboot()
            hw.mwsyn.close()

            hw.pg.reset()

            self.task_uca.close()
            self.task_zbd.close()
        except:
            print("I tried T^T")

    def _shutdown_exp(self):
        # self.reset_paraaset()
        # self.reset_dataset()

        hw.pg.forceFinal()
        hw.pg.constant(OutputState.ZERO())
        hw.pg.reset()

        # hw.mwsyn.close()
        self.task_uca.write([0])
        self.task_uca.stop()
        self.task_uca.close()

        self.task_zbd.stop()
        self.task_zbd.close()

        super()._shutdown_exp()
        # -----------------------------------------------------------
